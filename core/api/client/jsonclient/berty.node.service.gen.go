// this file was generated by protoc-gen-gotemplate
package jsonclient

import (
	"context"
	"encoding/json"

	"berty.tech/core/api/client"
	"berty.tech/core/api/node"
	"berty.tech/core/api/p2p"
	"berty.tech/core/entity"
	"berty.tech/core/network"
	"berty.tech/core/pkg/tracing"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

func init() {
	registerUnary("berty.node.ID", NodeID)
	registerServerStream("berty.node.CommitLogStream", NodeCommitLogStream)
	registerServerStream("berty.node.EventStream", NodeEventStream)
	registerServerStream("berty.node.EventList", NodeEventList)
	registerUnary("berty.node.GetEvent", NodeGetEvent)
	registerUnary("berty.node.EventSeen", NodeEventSeen)
	registerUnary("berty.node.ConfigPublic", NodeConfigPublic)
	registerUnary("berty.node.ConfigUpdate", NodeConfigUpdate)
	registerUnary("berty.node.ContactRequest", NodeContactRequest)
	registerUnary("berty.node.ContactAcceptRequest", NodeContactAcceptRequest)
	registerUnary("berty.node.ContactRemove", NodeContactRemove)
	registerUnary("berty.node.ContactUpdate", NodeContactUpdate)
	registerServerStream("berty.node.ContactList", NodeContactList)
	registerUnary("berty.node.Contact", NodeContact)
	registerUnary("berty.node.ContactCheckPublicKey", NodeContactCheckPublicKey)
	registerUnary("berty.node.ConversationCreate", NodeConversationCreate)
	registerServerStream("berty.node.ConversationList", NodeConversationList)
	registerUnary("berty.node.ConversationInvite", NodeConversationInvite)
	registerUnary("berty.node.ConversationExclude", NodeConversationExclude)
	registerUnary("berty.node.ConversationAddMessage", NodeConversationAddMessage)
	registerUnary("berty.node.Conversation", NodeConversation)
	registerUnary("berty.node.ConversationMember", NodeConversationMember)
	registerUnary("berty.node.ConversationRead", NodeConversationRead)
	registerUnary("berty.node.ConversationRemove", NodeConversationRemove)
	registerUnary("berty.node.ConversationLastEvent", NodeConversationLastEvent)
	registerUnary("berty.node.DevicePushConfigList", NodeDevicePushConfigList)
	registerUnary("berty.node.DevicePushConfigCreate", NodeDevicePushConfigCreate)
	registerUnary("berty.node.DevicePushConfigNativeRegister", NodeDevicePushConfigNativeRegister)
	registerUnary("berty.node.DevicePushConfigNativeUnregister", NodeDevicePushConfigNativeUnregister)
	registerUnary("berty.node.DevicePushConfigRemove", NodeDevicePushConfigRemove)
	registerUnary("berty.node.DevicePushConfigUpdate", NodeDevicePushConfigUpdate)
	registerUnary("berty.node.HandleEvent", NodeHandleEvent)
	registerUnary("berty.node.GenerateFakeData", NodeGenerateFakeData)
	registerUnary("berty.node.RunIntegrationTests", NodeRunIntegrationTests)
	registerUnary("berty.node.DebugPing", NodeDebugPing)
	registerUnary("berty.node.DebugRequeueEvent", NodeDebugRequeueEvent)
	registerUnary("berty.node.DebugRequeueAll", NodeDebugRequeueAll)
	registerUnary("berty.node.DeviceInfos", NodeDeviceInfos)
	registerUnary("berty.node.AppVersion", NodeAppVersion)
	registerUnary("berty.node.Peers", NodePeers)
	registerUnary("berty.node.Protocols", NodeProtocols)
	registerServerStream("berty.node.LogStream", NodeLogStream)
	registerServerStream("berty.node.LogfileList", NodeLogfileList)
	registerServerStream("berty.node.LogfileRead", NodeLogfileRead)
	registerUnary("berty.node.TestLogBackgroundError", NodeTestLogBackgroundError)
	registerUnary("berty.node.TestLogBackgroundWarn", NodeTestLogBackgroundWarn)
	registerUnary("berty.node.TestLogBackgroundDebug", NodeTestLogBackgroundDebug)
	registerUnary("berty.node.TestPanic", NodeTestPanic)
	registerUnary("berty.node.TestError", NodeTestError)
	registerServerStream("berty.node.MonitorBandwidth", NodeMonitorBandwidth)
	registerServerStream("berty.node.MonitorPeers", NodeMonitorPeers)
	registerUnary("berty.node.GetListenAddrs", NodeGetListenAddrs)
	registerUnary("berty.node.GetListenInterfaceAddrs", NodeGetListenInterfaceAddrs)
}
func NodeID(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ID")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ID(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeCommitLogStream(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "CommitLogStream"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().CommitLogStream(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeEventStream(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "EventStream"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.EventStreamInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().EventStream(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeEventList(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "EventList"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.EventListInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().EventList(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeGetEvent(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.GetEvent")
	var typedInput p2p.Event
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().GetEvent(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeEventSeen(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.EventSeen")
	var typedInput p2p.Event
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().EventSeen(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConfigPublic(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConfigPublic")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConfigPublic(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConfigUpdate(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConfigUpdate")
	var typedInput entity.Config
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConfigUpdate(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactRequest(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ContactRequest")
	var typedInput node.ContactRequestInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ContactRequest(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactAcceptRequest(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ContactAcceptRequest")
	var typedInput entity.Contact
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ContactAcceptRequest(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactRemove(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ContactRemove")
	var typedInput entity.Contact
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ContactRemove(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactUpdate(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ContactUpdate")
	var typedInput entity.Contact
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ContactUpdate(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactList(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "ContactList"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.ContactListInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().ContactList(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeContact(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.Contact")
	var typedInput node.ContactInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().Contact(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeContactCheckPublicKey(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ContactCheckPublicKey")
	var typedInput node.ContactInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ContactCheckPublicKey(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationCreate(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationCreate")
	var typedInput node.ConversationCreateInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationCreate(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationList(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "ConversationList"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.ConversationListInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().ConversationList(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeConversationInvite(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationInvite")
	var typedInput node.ConversationManageMembersInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationInvite(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationExclude(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationExclude")
	var typedInput node.ConversationManageMembersInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationExclude(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationAddMessage(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationAddMessage")
	var typedInput node.ConversationAddMessageInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationAddMessage(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversation(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.Conversation")
	var typedInput entity.Conversation
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().Conversation(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationMember(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationMember")
	var typedInput entity.ConversationMember
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationMember(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationRead(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationRead")
	var typedInput entity.Conversation
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationRead(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationRemove(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationRemove")
	var typedInput entity.Conversation
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationRemove(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeConversationLastEvent(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.ConversationLastEvent")
	var typedInput entity.Conversation
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().ConversationLastEvent(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigList(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigList")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigList(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigCreate(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigCreate")
	var typedInput node.DevicePushConfigCreateInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigCreate(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigNativeRegister(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigNativeRegister")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigNativeRegister(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigNativeUnregister(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigNativeUnregister")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigNativeUnregister(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigRemove(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigRemove")
	var typedInput entity.DevicePushConfig
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigRemove(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDevicePushConfigUpdate(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DevicePushConfigUpdate")
	var typedInput entity.DevicePushConfig
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DevicePushConfigUpdate(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeHandleEvent(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.HandleEvent")
	var typedInput p2p.Event
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().HandleEvent(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeGenerateFakeData(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.GenerateFakeData")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().GenerateFakeData(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeRunIntegrationTests(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.RunIntegrationTests")
	var typedInput node.IntegrationTestInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().RunIntegrationTests(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDebugPing(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DebugPing")
	var typedInput node.PingDestination
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DebugPing(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDebugRequeueEvent(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DebugRequeueEvent")
	var typedInput node.EventIDInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DebugRequeueEvent(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDebugRequeueAll(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DebugRequeueAll")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DebugRequeueAll(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeDeviceInfos(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.DeviceInfos")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().DeviceInfos(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeAppVersion(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.AppVersion")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().AppVersion(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodePeers(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.Peers")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().Peers(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeProtocols(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.Protocols")
	var typedInput network.Peer
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().Protocols(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeLogStream(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "LogStream"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.LogStreamInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().LogStream(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeLogfileList(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "LogfileList"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().LogfileList(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeLogfileRead(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "LogfileRead"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.LogfileReadInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().LogfileRead(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeTestLogBackgroundError(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.TestLogBackgroundError")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().TestLogBackgroundError(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeTestLogBackgroundWarn(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.TestLogBackgroundWarn")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().TestLogBackgroundWarn(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeTestLogBackgroundDebug(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.TestLogBackgroundDebug")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().TestLogBackgroundDebug(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeTestPanic(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.TestPanic")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().TestPanic(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeTestError(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.TestError")
	var typedInput node.TestErrorInput
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().TestError(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeMonitorBandwidth(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "MonitorBandwidth"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput network.BandwidthStats
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().MonitorBandwidth(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeMonitorPeers(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
	logger().Debug("client call",
		zap.String("service", "Service"),
		zap.String("method", "MonitorPeers"),
		zap.String("input", string(jsonInput)),
	)
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, err
	}
	stream, err := client.Node().MonitorPeers(ctx, &typedInput)
	if err != nil {
		return nil, err
	}
	// start a stream proxy
	streamProxy := newGenericServerStreamProxy()
	go func() {
		for {
			data, err := stream.Recv()
			streamProxy.queue <- genericStreamEntry{data: data, err: err}
			if err != nil {
				break
			}
		}
		// FIXME: wait for queue to be empty, then close chan
	}()
	return streamProxy, nil
}
func NodeGetListenAddrs(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.GetListenAddrs")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().GetListenAddrs(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
func NodeGetListenInterfaceAddrs(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()
	tracer.SetTag("full-method", "berty.node.GetListenInterfaceAddrs")
	var typedInput node.Void
	if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
		return nil, nil, nil, err
	}
	var header, trailer metadata.MD
	ret, err := client.Node().GetListenInterfaceAddrs(
		ctx,
		&typedInput,
		grpc.Header(&header),
		grpc.Trailer(&trailer),
	)
	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)
	return ret, header, trailer, err
}
