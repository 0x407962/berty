// this file was generated by protoc-gen-gotemplate

package jsonclient

{{- $file := .File}}

import (
       "context"
        "encoding/json"
        "berty.tech/core/{{.File.Name|dir}}"
        {{- range .File.Dependency -}}{{- $dependency := . | getProtoFile}}
        {{$dependency.GoPkg}}
        {{ end -}}
	"berty.tech/core/api/client"
        "google.golang.org/grpc"
)

{{- range $svc := .File.Service}}
{{- if eq ($svc.Name | lower) ($.Service.Name | lower)}}

  func init() {
     {{- range $method := .Method }}
     {{- if and (not .ClientStreaming) (not .ServerStreaming)}}
     registerUnary("{{$file.Package}}.{{$method.Name}}", {{$file.Package|splitList "."|last|title}}{{$method.Name}})
     {{- end}}
     {{- if and (not .ClientStreaming) (.ServerStreaming)}}
     registerServerStream("{{$file.Package}}.{{$method.Name}}", {{$file.Package|splitList "."|last|title}}{{$method.Name}})
     {{- end}}
     {{- end}}
  }

    {{ range $method := .Method}}
      {{if and (not .ClientStreaming) (not .ServerStreaming)}}
      func {{$file.Package|splitList "."|last|title}}{{$method.Name}}(client *client.Client, ctx context.Context, jsonInput []byte) (interface{}, metadata.MD, metadata.MD, error) {
	tracer := tracing.EnterFunc(ctx, string(jsonInput))
	defer tracer.Finish()
	ctx = tracer.Context()

	tracer.SetTag("full-method", "{{$file.Package}}.{{$method.Name}}")

        {{ $in := $method.InputType | getMessageType $file }}
        var typedInput {{$in.GoType "."}}
        if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
              return nil, nil, nil, err
        }

	var header, trailer metadata.MD
	ret, err := client.{{$file.Package|splitList "."|last|title}}().{{$method.Name}}(
            ctx,
            &typedInput,
            grpc.Header(&header),
            grpc.Trailer(&trailer),
        )

	tracer.SetAnyField("header", header)
	tracer.SetAnyField("trailer", trailer)

        return ret, header, trailer, err
      }
    {{- end}}
    {{if and (not .ClientStreaming) (.ServerStreaming)}}
      func {{$file.Package|splitList "."|last|title}}{{$method.Name}}(client *client.Client, ctx context.Context, jsonInput []byte) (GenericServerStreamClient, error) {
            logger().Debug("client call",
                  zap.String("service", "{{$svc.Name}}"),
                  zap.String("method", "{{$method.Name}}"),
                  zap.String("input", string(jsonInput)),
            )
            {{ $in := $method.InputType | getMessageType $file }}
            var typedInput {{$in.GoType "."}}
            if err := json.Unmarshal(jsonInput, &typedInput); err != nil {
                  return nil, err
            }
            stream, err := client.{{$file.Package|splitList "."|last|title}}().{{$method.Name}}(ctx, &typedInput)
            if err != nil {
                  return nil, err
            }

            // start a stream proxy
            streamProxy := newGenericServerStreamProxy()
            go func() {
                    for {
                            data, err := stream.Recv()
                            streamProxy.queue <- genericStreamEntry{data: data, err: err}
                            if err != nil {
                                    break
                            }
                    }
                    // FIXME: wait for queue to be empty, then close chan
            }()

            return streamProxy, nil
      }
    {{- end}}
  {{- end}}

{{end}}{{end}}
