// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: daemon/daemon.proto

package daemon

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Config_StoreType int32

const (
	Config_StoreMemory  Config_StoreType = 0
	Config_StorePersist Config_StoreType = 1
	Config_StoreNoop    Config_StoreType = 2
)

var Config_StoreType_name = map[int32]string{
	0: "StoreMemory",
	1: "StorePersist",
	2: "StoreNoop",
}

var Config_StoreType_value = map[string]int32{
	"StoreMemory":  0,
	"StorePersist": 1,
	"StoreNoop":    2,
}

func (x Config_StoreType) String() string {
	return proto.EnumName(Config_StoreType_name, int32(x))
}

func (Config_StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{7, 0}
}

type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{0}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

type SetCurrentRouteRequest struct {
	Route                string   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCurrentRouteRequest) Reset()         { *m = SetCurrentRouteRequest{} }
func (m *SetCurrentRouteRequest) String() string { return proto.CompactTextString(m) }
func (*SetCurrentRouteRequest) ProtoMessage()    {}
func (*SetCurrentRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{1}
}
func (m *SetCurrentRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCurrentRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCurrentRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCurrentRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCurrentRouteRequest.Merge(m, src)
}
func (m *SetCurrentRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCurrentRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCurrentRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCurrentRouteRequest proto.InternalMessageInfo

func (m *SetCurrentRouteRequest) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

type BotState struct {
	IsBotRunning         bool     `protobuf:"varint,1,opt,name=isBotRunning,proto3" json:"isBotRunning,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BotState) Reset()         { *m = BotState{} }
func (m *BotState) String() string { return proto.CompactTextString(m) }
func (*BotState) ProtoMessage()    {}
func (*BotState) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{2}
}
func (m *BotState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BotState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BotState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotState.Merge(m, src)
}
func (m *BotState) XXX_Size() int {
	return m.Size()
}
func (m *BotState) XXX_DiscardUnknown() {
	xxx_messageInfo_BotState.DiscardUnknown(m)
}

var xxx_messageInfo_BotState proto.InternalMessageInfo

func (m *BotState) GetIsBotRunning() bool {
	if m != nil {
		return m.IsBotRunning
	}
	return false
}

type StartRequest struct {
	Nickname             string   `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartRequest) Reset()         { *m = StartRequest{} }
func (m *StartRequest) String() string { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()    {}
func (*StartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{3}
}
func (m *StartRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRequest.Merge(m, src)
}
func (m *StartRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartRequest proto.InternalMessageInfo

func (m *StartRequest) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

// @TODO: switch to protobuf message instead of json
type GRPCInfos struct {
	Json                 string   `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GRPCInfos) Reset()         { *m = GRPCInfos{} }
func (m *GRPCInfos) String() string { return proto.CompactTextString(m) }
func (*GRPCInfos) ProtoMessage()    {}
func (*GRPCInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{4}
}
func (m *GRPCInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRPCInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRPCInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRPCInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRPCInfos.Merge(m, src)
}
func (m *GRPCInfos) XXX_Size() int {
	return m.Size()
}
func (m *GRPCInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_GRPCInfos.DiscardUnknown(m)
}

var xxx_messageInfo_GRPCInfos proto.InternalMessageInfo

func (m *GRPCInfos) GetJson() string {
	if m != nil {
		return m.Json
	}
	return ""
}

// Network Config
type NetworkConfig struct {
	PeerCache            bool     `protobuf:"varint,1,opt,name=peerCache,proto3" json:"peerCache,omitempty"`
	Identity             string   `protobuf:"bytes,2,opt,name=identity,proto3" json:"identity,omitempty"`
	Bootstrap            []string `protobuf:"bytes,3,rep,name=bootstrap,proto3" json:"bootstrap,omitempty"`
	BindP2P              []string `protobuf:"bytes,5,rep,name=bindP2P,proto3" json:"bindP2P,omitempty"`
	Mdns                 bool     `protobuf:"varint,6,opt,name=mdns,proto3" json:"mdns,omitempty"`
	PrivateNetwork       bool     `protobuf:"varint,7,opt,name=privateNetwork,proto3" json:"privateNetwork,omitempty"`
	Ipfs                 bool     `protobuf:"varint,8,opt,name=ipfs,proto3" json:"ipfs,omitempty"`
	Mobile               bool     `protobuf:"varint,9,opt,name=mobile,proto3" json:"mobile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkConfig) Reset()         { *m = NetworkConfig{} }
func (m *NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkConfig) ProtoMessage()    {}
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{5}
}
func (m *NetworkConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfig.Merge(m, src)
}
func (m *NetworkConfig) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfig proto.InternalMessageInfo

func (m *NetworkConfig) GetPeerCache() bool {
	if m != nil {
		return m.PeerCache
	}
	return false
}

func (m *NetworkConfig) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *NetworkConfig) GetBootstrap() []string {
	if m != nil {
		return m.Bootstrap
	}
	return nil
}

func (m *NetworkConfig) GetBindP2P() []string {
	if m != nil {
		return m.BindP2P
	}
	return nil
}

func (m *NetworkConfig) GetMdns() bool {
	if m != nil {
		return m.Mdns
	}
	return false
}

func (m *NetworkConfig) GetPrivateNetwork() bool {
	if m != nil {
		return m.PrivateNetwork
	}
	return false
}

func (m *NetworkConfig) GetIpfs() bool {
	if m != nil {
		return m.Ipfs
	}
	return false
}

func (m *NetworkConfig) GetMobile() bool {
	if m != nil {
		return m.Mobile
	}
	return false
}

type SQLConfig struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SQLConfig) Reset()         { *m = SQLConfig{} }
func (m *SQLConfig) String() string { return proto.CompactTextString(m) }
func (*SQLConfig) ProtoMessage()    {}
func (*SQLConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{6}
}
func (m *SQLConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLConfig.Merge(m, src)
}
func (m *SQLConfig) XXX_Size() int {
	return m.Size()
}
func (m *SQLConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SQLConfig proto.InternalMessageInfo

func (m *SQLConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SQLConfig) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type Config struct {
	SqlOpts              *SQLConfig       `protobuf:"bytes,1,opt,name=sqlOpts,proto3" json:"sqlOpts,omitempty"`
	GrpcBind             string           `protobuf:"bytes,2,opt,name=grpcBind,proto3" json:"grpcBind,omitempty"`
	GrpcWebBind          string           `protobuf:"bytes,3,opt,name=grpcWebBind,proto3" json:"grpcWebBind,omitempty"`
	HideBanner           bool             `protobuf:"varint,4,opt,name=hideBanner,proto3" json:"hideBanner,omitempty"`
	DropDatabase         bool             `protobuf:"varint,5,opt,name=dropDatabase,proto3" json:"dropDatabase,omitempty"`
	InitOnly             bool             `protobuf:"varint,6,opt,name=initOnly,proto3" json:"initOnly,omitempty"`
	WithBot              bool             `protobuf:"varint,7,opt,name=withBot,proto3" json:"withBot,omitempty"`
	Notification         bool             `protobuf:"varint,8,opt,name=notification,proto3" json:"notification,omitempty"`
	ApnsCerts            []string         `protobuf:"bytes,9,rep,name=apnsCerts,proto3" json:"apnsCerts,omitempty"`
	ApnsDevVoipCerts     []string         `protobuf:"bytes,10,rep,name=apnsDevVoipCerts,proto3" json:"apnsDevVoipCerts,omitempty"`
	FcmAPIKeys           []string         `protobuf:"bytes,11,rep,name=fcmAPIKeys,proto3" json:"fcmAPIKeys,omitempty"`
	PrivateKeyFile       string           `protobuf:"bytes,12,opt,name=privateKeyFile,proto3" json:"privateKeyFile,omitempty"`
	NetworkConfig        *NetworkConfig   `protobuf:"bytes,13,opt,name=networkConfig,proto3" json:"networkConfig,omitempty"`
	NoP2P                bool             `protobuf:"varint,14,opt,name=noP2P,proto3" json:"noP2P,omitempty"`
	StoreType            Config_StoreType `protobuf:"varint,15,opt,name=storeType,proto3,enum=berty.daemon.Config_StoreType" json:"storeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{7}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetSqlOpts() *SQLConfig {
	if m != nil {
		return m.SqlOpts
	}
	return nil
}

func (m *Config) GetGrpcBind() string {
	if m != nil {
		return m.GrpcBind
	}
	return ""
}

func (m *Config) GetGrpcWebBind() string {
	if m != nil {
		return m.GrpcWebBind
	}
	return ""
}

func (m *Config) GetHideBanner() bool {
	if m != nil {
		return m.HideBanner
	}
	return false
}

func (m *Config) GetDropDatabase() bool {
	if m != nil {
		return m.DropDatabase
	}
	return false
}

func (m *Config) GetInitOnly() bool {
	if m != nil {
		return m.InitOnly
	}
	return false
}

func (m *Config) GetWithBot() bool {
	if m != nil {
		return m.WithBot
	}
	return false
}

func (m *Config) GetNotification() bool {
	if m != nil {
		return m.Notification
	}
	return false
}

func (m *Config) GetApnsCerts() []string {
	if m != nil {
		return m.ApnsCerts
	}
	return nil
}

func (m *Config) GetApnsDevVoipCerts() []string {
	if m != nil {
		return m.ApnsDevVoipCerts
	}
	return nil
}

func (m *Config) GetFcmAPIKeys() []string {
	if m != nil {
		return m.FcmAPIKeys
	}
	return nil
}

func (m *Config) GetPrivateKeyFile() string {
	if m != nil {
		return m.PrivateKeyFile
	}
	return ""
}

func (m *Config) GetNetworkConfig() *NetworkConfig {
	if m != nil {
		return m.NetworkConfig
	}
	return nil
}

func (m *Config) GetNoP2P() bool {
	if m != nil {
		return m.NoP2P
	}
	return false
}

func (m *Config) GetStoreType() Config_StoreType {
	if m != nil {
		return m.StoreType
	}
	return Config_StoreMemory
}

// @TODO: list all ports available
type GetPortResponse struct {
	GrpcWebPort          int32    `protobuf:"varint,2,opt,name=grpcWebPort,proto3" json:"grpcWebPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPortResponse) Reset()         { *m = GetPortResponse{} }
func (m *GetPortResponse) String() string { return proto.CompactTextString(m) }
func (*GetPortResponse) ProtoMessage()    {}
func (*GetPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{8}
}
func (m *GetPortResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPortResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPortResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPortResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPortResponse.Merge(m, src)
}
func (m *GetPortResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPortResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPortResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPortResponse proto.InternalMessageInfo

func (m *GetPortResponse) GetGrpcWebPort() int32 {
	if m != nil {
		return m.GrpcWebPort
	}
	return 0
}

type ListAccountsResponse struct {
	Accounts             []string `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccountsResponse) Reset()         { *m = ListAccountsResponse{} }
func (m *ListAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAccountsResponse) ProtoMessage()    {}
func (*ListAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{9}
}
func (m *ListAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccountsResponse.Merge(m, src)
}
func (m *ListAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccountsResponse proto.InternalMessageInfo

func (m *ListAccountsResponse) GetAccounts() []string {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func init() {
	proto.RegisterEnum("berty.daemon.Config_StoreType", Config_StoreType_name, Config_StoreType_value)
	proto.RegisterType((*Void)(nil), "berty.daemon.Void")
	proto.RegisterType((*SetCurrentRouteRequest)(nil), "berty.daemon.SetCurrentRouteRequest")
	proto.RegisterType((*BotState)(nil), "berty.daemon.BotState")
	proto.RegisterType((*StartRequest)(nil), "berty.daemon.StartRequest")
	proto.RegisterType((*GRPCInfos)(nil), "berty.daemon.GRPCInfos")
	proto.RegisterType((*NetworkConfig)(nil), "berty.daemon.NetworkConfig")
	proto.RegisterType((*SQLConfig)(nil), "berty.daemon.SQLConfig")
	proto.RegisterType((*Config)(nil), "berty.daemon.Config")
	proto.RegisterType((*GetPortResponse)(nil), "berty.daemon.GetPortResponse")
	proto.RegisterType((*ListAccountsResponse)(nil), "berty.daemon.ListAccountsResponse")
}

func init() { proto.RegisterFile("daemon/daemon.proto", fileDescriptor_622b4ce7acb47fee) }

var fileDescriptor_622b4ce7acb47fee = []byte{
	// 924 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xb7, 0x1b, 0xff, 0x1d, 0xdb, 0x89, 0xd9, 0x46, 0xe1, 0x14, 0xc0, 0x44, 0x27, 0x84, 0xa2,
	0x3e, 0xb8, 0x8a, 0xc3, 0x43, 0xcb, 0x3f, 0x29, 0x76, 0xc0, 0x8d, 0x9a, 0xb6, 0xe6, 0x0c, 0x45,
	0xe2, 0xed, 0x7c, 0x1e, 0x27, 0x4b, 0xec, 0xdd, 0xeb, 0xee, 0xb8, 0x95, 0xf9, 0x24, 0x7c, 0x24,
	0x1e, 0xf9, 0x08, 0x28, 0x3c, 0x21, 0xf1, 0x1d, 0x40, 0xbb, 0x77, 0xe7, 0xdc, 0x99, 0x4b, 0x45,
	0xfa, 0x74, 0x3b, 0xbf, 0x9d, 0xdf, 0xcc, 0xce, 0x9f, 0x9d, 0x3d, 0xb8, 0x3f, 0xf5, 0x71, 0x21,
	0xc5, 0xc3, 0xe8, 0xd3, 0x0d, 0x95, 0x24, 0xc9, 0x9a, 0x13, 0x54, 0xb4, 0xea, 0x46, 0x98, 0x5b,
	0x81, 0xd2, 0x4b, 0xc9, 0xa7, 0x6e, 0x17, 0xf6, 0xc6, 0x48, 0x83, 0xa5, 0x52, 0x28, 0xc8, 0x93,
	0x4b, 0x42, 0x0f, 0x5f, 0x2d, 0x51, 0x13, 0xdb, 0x85, 0xb2, 0x32, 0xb2, 0x53, 0x3c, 0x28, 0x1e,
	0xd6, 0xbd, 0x48, 0x70, 0xbb, 0x50, 0xeb, 0x4b, 0x1a, 0x93, 0x4f, 0xc8, 0x5c, 0x68, 0x72, 0xdd,
	0x97, 0xe4, 0x2d, 0x85, 0xe0, 0xe2, 0xc2, 0x2a, 0xd6, 0xbc, 0x0c, 0xe6, 0x3e, 0x80, 0xe6, 0x98,
	0x7c, 0x45, 0x89, 0xd5, 0x7d, 0xa8, 0x09, 0x1e, 0x5c, 0x09, 0x7f, 0x91, 0x18, 0x5e, 0xcb, 0xee,
	0xc7, 0x50, 0x1f, 0x7a, 0xa3, 0xc1, 0x99, 0x98, 0x49, 0xcd, 0x18, 0x94, 0x7e, 0xd6, 0x52, 0xc4,
	0x4a, 0x76, 0xed, 0xfe, 0x55, 0x84, 0xd6, 0x73, 0xa4, 0x37, 0x52, 0x5d, 0x0d, 0xa4, 0x98, 0xf1,
	0x0b, 0xf6, 0x21, 0xd4, 0x43, 0x44, 0x35, 0xf0, 0x83, 0x4b, 0x8c, 0xfd, 0xdf, 0x00, 0xc6, 0x19,
	0x9f, 0xa2, 0x20, 0x4e, 0x2b, 0xe7, 0x5e, 0xe4, 0x2c, 0x91, 0x0d, 0x73, 0x22, 0x25, 0x69, 0x52,
	0x7e, 0xe8, 0x6c, 0x1d, 0x6c, 0x1d, 0xd6, 0xbd, 0x1b, 0x80, 0x39, 0x50, 0x9d, 0x70, 0x31, 0x1d,
	0xf5, 0x46, 0x4e, 0xd9, 0xee, 0x25, 0xa2, 0x39, 0xd7, 0x62, 0x2a, 0xb4, 0x53, 0xb1, 0xce, 0xec,
	0x9a, 0x7d, 0x0a, 0xdb, 0xa1, 0xe2, 0xaf, 0x7d, 0xc2, 0xf8, 0x74, 0x4e, 0xd5, 0xee, 0x6e, 0xa0,
	0x86, 0xcb, 0xc3, 0x99, 0x76, 0x6a, 0x11, 0xd7, 0xac, 0xd9, 0x1e, 0x54, 0x16, 0x72, 0xc2, 0xe7,
	0xe8, 0xd4, 0x2d, 0x1a, 0x4b, 0xee, 0x11, 0xd4, 0xc7, 0xdf, 0x9d, 0xc7, 0x61, 0x32, 0x28, 0xa5,
	0x32, 0x66, 0xd7, 0xac, 0x0d, 0x5b, 0x57, 0x98, 0xc4, 0x65, 0x96, 0xee, 0x3f, 0x25, 0xa8, 0xc4,
	0x84, 0x23, 0xa8, 0xea, 0x57, 0xf3, 0x17, 0x21, 0x69, 0xcb, 0x69, 0xf4, 0xde, 0xef, 0xa6, 0xcb,
	0xdf, 0x5d, 0x9b, 0xf6, 0x12, 0x3d, 0x93, 0xac, 0x0b, 0x15, 0x06, 0x7d, 0x2e, 0xa6, 0x49, 0xb2,
	0x12, 0x99, 0x1d, 0x40, 0xc3, 0xac, 0x7f, 0xc4, 0x89, 0xdd, 0xde, 0xb2, 0xdb, 0x69, 0x88, 0x75,
	0x00, 0x2e, 0xf9, 0x14, 0xfb, 0xbe, 0x10, 0xa8, 0x9c, 0x92, 0x0d, 0x25, 0x85, 0x98, 0x5e, 0x99,
	0x2a, 0x19, 0x9e, 0xfa, 0xe4, 0x4f, 0x7c, 0x8d, 0x4e, 0x39, 0xea, 0x95, 0x34, 0x66, 0xcb, 0x25,
	0x38, 0xbd, 0x10, 0xf3, 0x55, 0x9c, 0xde, 0xb5, 0x6c, 0x0a, 0xf2, 0x86, 0xd3, 0x65, 0x5f, 0x52,
	0x9c, 0xdb, 0x44, 0x34, 0x96, 0x85, 0x24, 0x3e, 0xe3, 0x81, 0x4f, 0x5c, 0x8a, 0x38, 0xb9, 0x19,
	0xcc, 0x14, 0xdb, 0x0f, 0x85, 0x1e, 0xa0, 0x22, 0xed, 0xd4, 0xa3, 0x62, 0xaf, 0x01, 0xf6, 0x00,
	0xda, 0x46, 0x38, 0xc5, 0xd7, 0x2f, 0x25, 0x0f, 0x23, 0x25, 0xb0, 0x4a, 0xff, 0xc1, 0x4d, 0x9c,
	0xb3, 0x60, 0x71, 0x32, 0x3a, 0x7b, 0x8a, 0x2b, 0xed, 0x34, 0xac, 0x56, 0x0a, 0x49, 0xb5, 0xc2,
	0x53, 0x5c, 0x7d, 0x6b, 0xca, 0xda, 0xb4, 0xc9, 0xda, 0x40, 0xd9, 0x09, 0xb4, 0x44, 0xba, 0x93,
	0x9d, 0x96, 0x2d, 0xd3, 0x07, 0xd9, 0x32, 0x65, 0x9a, 0xdd, 0xcb, 0x32, 0xcc, 0x05, 0x15, 0xd2,
	0x74, 0xe8, 0xb6, 0x8d, 0x38, 0x12, 0xd8, 0x97, 0x50, 0xd7, 0x24, 0x15, 0x7e, 0xbf, 0x0a, 0xd1,
	0xd9, 0x39, 0x28, 0x1e, 0x6e, 0xf7, 0x3a, 0x59, 0xa3, 0x11, 0xbd, 0x3b, 0x4e, 0xb4, 0xbc, 0x1b,
	0x82, 0xfb, 0x15, 0xd4, 0xd7, 0x38, 0xdb, 0x81, 0x86, 0x15, 0x9e, 0xe1, 0x42, 0xaa, 0x55, 0xbb,
	0xc0, 0xda, 0xe6, 0x32, 0x4b, 0x85, 0x23, 0x54, 0x9a, 0x6b, 0x6a, 0x17, 0x59, 0x2b, 0xd6, 0x7f,
	0x2e, 0x65, 0xd8, 0xbe, 0xe7, 0x1e, 0xc3, 0xce, 0x10, 0x69, 0x24, 0xcd, 0x7d, 0xd7, 0xa1, 0x14,
	0x1a, 0x53, 0xad, 0x63, 0x60, 0xdb, 0x59, 0x65, 0x2f, 0x0d, 0xb9, 0x3d, 0xd8, 0x3d, 0xe7, 0x9a,
	0x4e, 0x82, 0x40, 0x2e, 0x05, 0xe9, 0x35, 0x73, 0x1f, 0x6a, 0x7e, 0x8c, 0x39, 0x45, 0x9b, 0xe8,
	0xb5, 0xdc, 0xfb, 0xbb, 0x0a, 0x95, 0x53, 0x1b, 0x0e, 0x7b, 0x04, 0xcd, 0xd3, 0x74, 0x17, 0xb1,
	0x6c, 0xb4, 0x66, 0xca, 0xed, 0xe7, 0x60, 0x6e, 0x81, 0xf5, 0xe1, 0xbd, 0x21, 0xd2, 0xb9, 0x0c,
	0xfc, 0xf9, 0x50, 0x85, 0x41, 0x3c, 0x77, 0x72, 0xe8, 0x1b, 0x97, 0x67, 0x3d, 0xa4, 0xdc, 0x02,
	0xfb, 0x06, 0xda, 0x43, 0xa4, 0xec, 0x50, 0xca, 0x33, 0xf1, 0xb6, 0xc2, 0xba, 0x05, 0xf6, 0x35,
	0x54, 0xe3, 0xc4, 0xe5, 0xb2, 0x3f, 0xda, 0x38, 0x40, 0x36, 0xc7, 0x6e, 0x81, 0x3d, 0x02, 0x38,
	0x13, 0x9c, 0xb8, 0x3f, 0xe7, 0xbf, 0x20, 0xdb, 0xcd, 0x2b, 0xf8, 0x2d, 0x49, 0xf8, 0x02, 0x1a,
	0x43, 0xa4, 0xf5, 0x4c, 0xcf, 0xf3, 0xbe, 0x97, 0xc5, 0x12, 0x5d, 0xb7, 0xc0, 0x9e, 0x40, 0x33,
	0x5d, 0xba, 0x5c, 0xb6, 0x9b, 0xc5, 0xf2, 0x4a, 0xed, 0x16, 0xd8, 0x11, 0x94, 0x47, 0xbe, 0xe0,
	0xc1, 0x1d, 0xca, 0x77, 0x0c, 0x55, 0x0f, 0xb5, 0x79, 0x5c, 0xee, 0x40, 0x7a, 0x06, 0x3b, 0x1b,
	0xef, 0x1d, 0xfb, 0x64, 0x63, 0x34, 0xe6, 0x3e, 0x87, 0xb7, 0x98, 0x7b, 0x0c, 0x65, 0xfb, 0xbc,
	0xb1, 0xfd, 0x0d, 0x23, 0xa9, 0x37, 0xef, 0x16, 0xea, 0x67, 0x50, 0xb3, 0x5a, 0x66, 0x86, 0xfd,
	0xff, 0xf3, 0x7f, 0x0e, 0xdb, 0x96, 0x15, 0x75, 0xad, 0x37, 0x1a, 0xdc, 0x2d, 0x61, 0x63, 0x92,
	0xe1, 0xdd, 0x1c, 0x3e, 0x86, 0x96, 0x21, 0xbd, 0x8b, 0xbf, 0x27, 0x70, 0xff, 0x87, 0x70, 0x7a,
	0xf3, 0xfe, 0xc5, 0xd7, 0xe3, 0x6d, 0x57, 0x21, 0xdf, 0x52, 0xff, 0xf0, 0xb7, 0xeb, 0x4e, 0xf1,
	0xf7, 0xeb, 0x4e, 0xf1, 0x8f, 0xeb, 0x4e, 0xf1, 0xd7, 0x3f, 0x3b, 0x85, 0x9f, 0xf6, 0x22, 0x35,
	0xc2, 0xe0, 0xf2, 0x61, 0x20, 0x15, 0xc6, 0xff, 0x3a, 0x93, 0x8a, 0xfd, 0xd9, 0x39, 0xfe, 0x37,
	0x00, 0x00, 0xff, 0xff, 0x2f, 0x92, 0xe5, 0x21, 0x03, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DaemonClient interface {
	DropDatabase(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	GetLocalGrpcInfos(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GRPCInfos, error)
	GetNetworkConfig(ctx context.Context, in *Void, opts ...grpc.CallOption) (*NetworkConfig, error)
	GetPort(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GetPortResponse, error)
	Initialize(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error)
	GetBotState(ctx context.Context, in *Void, opts ...grpc.CallOption) (*BotState, error)
	ListAccounts(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	Panic(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	Restart(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	SetCurrentRoute(ctx context.Context, in *SetCurrentRouteRequest, opts ...grpc.CallOption) (*Void, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Void, error)
	StartBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StartLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StopBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StopLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	UpdateNetworkConfig(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*Void, error)
}

type daemonClient struct {
	cc *grpc.ClientConn
}

func NewDaemonClient(cc *grpc.ClientConn) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) DropDatabase(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/DropDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetLocalGrpcInfos(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GRPCInfos, error) {
	out := new(GRPCInfos)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetLocalGrpcInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetNetworkConfig(ctx context.Context, in *Void, opts ...grpc.CallOption) (*NetworkConfig, error) {
	out := new(NetworkConfig)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetPort(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GetPortResponse, error) {
	out := new(GetPortResponse)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Initialize(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Initialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetBotState(ctx context.Context, in *Void, opts ...grpc.CallOption) (*BotState, error) {
	out := new(BotState)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetBotState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListAccounts(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/ListAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Panic(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Panic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Restart(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetCurrentRoute(ctx context.Context, in *SetCurrentRouteRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/SetCurrentRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StartBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StartBot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StartLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StartLocalGRPC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StopBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StopBot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StopLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StopLocalGRPC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UpdateNetworkConfig(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/UpdateNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
type DaemonServer interface {
	DropDatabase(context.Context, *Void) (*Void, error)
	GetLocalGrpcInfos(context.Context, *Void) (*GRPCInfos, error)
	GetNetworkConfig(context.Context, *Void) (*NetworkConfig, error)
	GetPort(context.Context, *Void) (*GetPortResponse, error)
	Initialize(context.Context, *Config) (*Void, error)
	GetBotState(context.Context, *Void) (*BotState, error)
	ListAccounts(context.Context, *Void) (*ListAccountsResponse, error)
	Panic(context.Context, *Void) (*Void, error)
	Restart(context.Context, *Void) (*Void, error)
	SetCurrentRoute(context.Context, *SetCurrentRouteRequest) (*Void, error)
	Start(context.Context, *StartRequest) (*Void, error)
	StartBot(context.Context, *Void) (*Void, error)
	StartLocalGRPC(context.Context, *Void) (*Void, error)
	StopBot(context.Context, *Void) (*Void, error)
	StopLocalGRPC(context.Context, *Void) (*Void, error)
	UpdateNetworkConfig(context.Context, *NetworkConfig) (*Void, error)
}

// UnimplementedDaemonServer can be embedded to have forward compatible implementations.
type UnimplementedDaemonServer struct {
}

func (*UnimplementedDaemonServer) DropDatabase(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropDatabase not implemented")
}
func (*UnimplementedDaemonServer) GetLocalGrpcInfos(ctx context.Context, req *Void) (*GRPCInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocalGrpcInfos not implemented")
}
func (*UnimplementedDaemonServer) GetNetworkConfig(ctx context.Context, req *Void) (*NetworkConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkConfig not implemented")
}
func (*UnimplementedDaemonServer) GetPort(ctx context.Context, req *Void) (*GetPortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPort not implemented")
}
func (*UnimplementedDaemonServer) Initialize(ctx context.Context, req *Config) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (*UnimplementedDaemonServer) GetBotState(ctx context.Context, req *Void) (*BotState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBotState not implemented")
}
func (*UnimplementedDaemonServer) ListAccounts(ctx context.Context, req *Void) (*ListAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccounts not implemented")
}
func (*UnimplementedDaemonServer) Panic(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Panic not implemented")
}
func (*UnimplementedDaemonServer) Restart(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (*UnimplementedDaemonServer) SetCurrentRoute(ctx context.Context, req *SetCurrentRouteRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentRoute not implemented")
}
func (*UnimplementedDaemonServer) Start(ctx context.Context, req *StartRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (*UnimplementedDaemonServer) StartBot(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartBot not implemented")
}
func (*UnimplementedDaemonServer) StartLocalGRPC(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartLocalGRPC not implemented")
}
func (*UnimplementedDaemonServer) StopBot(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopBot not implemented")
}
func (*UnimplementedDaemonServer) StopLocalGRPC(ctx context.Context, req *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopLocalGRPC not implemented")
}
func (*UnimplementedDaemonServer) UpdateNetworkConfig(ctx context.Context, req *NetworkConfig) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNetworkConfig not implemented")
}

func RegisterDaemonServer(s *grpc.Server, srv DaemonServer) {
	s.RegisterService(&_Daemon_serviceDesc, srv)
}

func _Daemon_DropDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).DropDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/DropDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).DropDatabase(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetLocalGrpcInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetLocalGrpcInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetLocalGrpcInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetLocalGrpcInfos(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetNetworkConfig(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetPort(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Initialize(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetBotState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetBotState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetBotState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetBotState(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/ListAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListAccounts(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Panic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Panic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Panic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Panic(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Restart(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetCurrentRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetCurrentRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/SetCurrentRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetCurrentRoute(ctx, req.(*SetCurrentRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StartBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StartBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StartBot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StartBot(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StartLocalGRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StartLocalGRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StartLocalGRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StartLocalGRPC(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StopBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StopBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StopBot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StopBot(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StopLocalGRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StopLocalGRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StopLocalGRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StopLocalGRPC(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UpdateNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UpdateNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/UpdateNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UpdateNetworkConfig(ctx, req.(*NetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

var _Daemon_serviceDesc = grpc.ServiceDesc{
	ServiceName: "berty.daemon.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DropDatabase",
			Handler:    _Daemon_DropDatabase_Handler,
		},
		{
			MethodName: "GetLocalGrpcInfos",
			Handler:    _Daemon_GetLocalGrpcInfos_Handler,
		},
		{
			MethodName: "GetNetworkConfig",
			Handler:    _Daemon_GetNetworkConfig_Handler,
		},
		{
			MethodName: "GetPort",
			Handler:    _Daemon_GetPort_Handler,
		},
		{
			MethodName: "Initialize",
			Handler:    _Daemon_Initialize_Handler,
		},
		{
			MethodName: "GetBotState",
			Handler:    _Daemon_GetBotState_Handler,
		},
		{
			MethodName: "ListAccounts",
			Handler:    _Daemon_ListAccounts_Handler,
		},
		{
			MethodName: "Panic",
			Handler:    _Daemon_Panic_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _Daemon_Restart_Handler,
		},
		{
			MethodName: "SetCurrentRoute",
			Handler:    _Daemon_SetCurrentRoute_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Daemon_Start_Handler,
		},
		{
			MethodName: "StartBot",
			Handler:    _Daemon_StartBot_Handler,
		},
		{
			MethodName: "StartLocalGRPC",
			Handler:    _Daemon_StartLocalGRPC_Handler,
		},
		{
			MethodName: "StopBot",
			Handler:    _Daemon_StopBot_Handler,
		},
		{
			MethodName: "StopLocalGRPC",
			Handler:    _Daemon_StopLocalGRPC_Handler,
		},
		{
			MethodName: "UpdateNetworkConfig",
			Handler:    _Daemon_UpdateNetworkConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon/daemon.proto",
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Void) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SetCurrentRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCurrentRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCurrentRouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Route) > 0 {
		i -= len(m.Route)
		copy(dAtA[i:], m.Route)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Route)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BotState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsBotRunning {
		i--
		if m.IsBotRunning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nickname) > 0 {
		i -= len(m.Nickname)
		copy(dAtA[i:], m.Nickname)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Nickname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GRPCInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRPCInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GRPCInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mobile {
		i--
		if m.Mobile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Ipfs {
		i--
		if m.Ipfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PrivateNetwork {
		i--
		if m.PrivateNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Mdns {
		i--
		if m.Mdns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.BindP2P) > 0 {
		for iNdEx := len(m.BindP2P) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BindP2P[iNdEx])
			copy(dAtA[i:], m.BindP2P[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.BindP2P[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Bootstrap) > 0 {
		for iNdEx := len(m.Bootstrap) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Bootstrap[iNdEx])
			copy(dAtA[i:], m.Bootstrap[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.Bootstrap[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x12
	}
	if m.PeerCache {
		i--
		if m.PeerCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SQLConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StoreType != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.StoreType))
		i--
		dAtA[i] = 0x78
	}
	if m.NoP2P {
		i--
		if m.NoP2P {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.NetworkConfig != nil {
		{
			size, err := m.NetworkConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.PrivateKeyFile) > 0 {
		i -= len(m.PrivateKeyFile)
		copy(dAtA[i:], m.PrivateKeyFile)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.PrivateKeyFile)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.FcmAPIKeys) > 0 {
		for iNdEx := len(m.FcmAPIKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FcmAPIKeys[iNdEx])
			copy(dAtA[i:], m.FcmAPIKeys[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.FcmAPIKeys[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ApnsDevVoipCerts) > 0 {
		for iNdEx := len(m.ApnsDevVoipCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApnsDevVoipCerts[iNdEx])
			copy(dAtA[i:], m.ApnsDevVoipCerts[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.ApnsDevVoipCerts[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ApnsCerts) > 0 {
		for iNdEx := len(m.ApnsCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApnsCerts[iNdEx])
			copy(dAtA[i:], m.ApnsCerts[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.ApnsCerts[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Notification {
		i--
		if m.Notification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.WithBot {
		i--
		if m.WithBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.InitOnly {
		i--
		if m.InitOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DropDatabase {
		i--
		if m.DropDatabase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.HideBanner {
		i--
		if m.HideBanner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.GrpcWebBind) > 0 {
		i -= len(m.GrpcWebBind)
		copy(dAtA[i:], m.GrpcWebBind)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.GrpcWebBind)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GrpcBind) > 0 {
		i -= len(m.GrpcBind)
		copy(dAtA[i:], m.GrpcBind)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.GrpcBind)))
		i--
		dAtA[i] = 0x12
	}
	if m.SqlOpts != nil {
		{
			size, err := m.SqlOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetPortResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPortResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPortResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GrpcWebPort != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.GrpcWebPort))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *ListAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAccountsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Accounts[iNdEx])
			copy(dAtA[i:], m.Accounts[iNdEx])
			i = encodeVarintDaemon(dAtA, i, uint64(len(m.Accounts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDaemon(dAtA []byte, offset int, v uint64) int {
	offset -= sovDaemon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCurrentRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BotState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsBotRunning {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GRPCInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerCache {
		n += 2
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.Bootstrap) > 0 {
		for _, s := range m.Bootstrap {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.BindP2P) > 0 {
		for _, s := range m.BindP2P {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.Mdns {
		n += 2
	}
	if m.PrivateNetwork {
		n += 2
	}
	if m.Ipfs {
		n += 2
	}
	if m.Mobile {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SQLConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlOpts != nil {
		l = m.SqlOpts.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.GrpcBind)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.GrpcWebBind)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.HideBanner {
		n += 2
	}
	if m.DropDatabase {
		n += 2
	}
	if m.InitOnly {
		n += 2
	}
	if m.WithBot {
		n += 2
	}
	if m.Notification {
		n += 2
	}
	if len(m.ApnsCerts) > 0 {
		for _, s := range m.ApnsCerts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.ApnsDevVoipCerts) > 0 {
		for _, s := range m.ApnsDevVoipCerts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.FcmAPIKeys) > 0 {
		for _, s := range m.FcmAPIKeys {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.PrivateKeyFile)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.NetworkConfig != nil {
		l = m.NetworkConfig.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.NoP2P {
		n += 2
	}
	if m.StoreType != 0 {
		n += 1 + sovDaemon(uint64(m.StoreType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPortResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GrpcWebPort != 0 {
		n += 1 + sovDaemon(uint64(m.GrpcWebPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, s := range m.Accounts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDaemon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDaemon(x uint64) (n int) {
	return sovDaemon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCurrentRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCurrentRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCurrentRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBotRunning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBotRunning = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRPCInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRPCInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRPCInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerCache = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bootstrap = append(m.Bootstrap, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindP2P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindP2P = append(m.BindP2P, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mdns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mdns = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrivateNetwork = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ipfs = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mobile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SqlOpts == nil {
				m.SqlOpts = &SQLConfig{}
			}
			if err := m.SqlOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcBind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcBind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcWebBind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcWebBind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideBanner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideBanner = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropDatabase = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBot = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Notification = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApnsCerts = append(m.ApnsCerts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsDevVoipCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApnsDevVoipCerts = append(m.ApnsDevVoipCerts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcmAPIKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FcmAPIKeys = append(m.FcmAPIKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkConfig == nil {
				m.NetworkConfig = &NetworkConfig{}
			}
			if err := m.NetworkConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoP2P", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoP2P = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreType", wireType)
			}
			m.StoreType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreType |= Config_StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPortResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPortResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPortResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcWebPort", wireType)
			}
			m.GrpcWebPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcWebPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDaemon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDaemon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDaemon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDaemon
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDaemon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDaemon   = fmt.Errorf("proto: integer overflow")
)
