// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: daemon/daemon.proto

package daemon

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{0}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

type SetCurrentRouteRequest struct {
	Route                string   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCurrentRouteRequest) Reset()         { *m = SetCurrentRouteRequest{} }
func (m *SetCurrentRouteRequest) String() string { return proto.CompactTextString(m) }
func (*SetCurrentRouteRequest) ProtoMessage()    {}
func (*SetCurrentRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{1}
}
func (m *SetCurrentRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCurrentRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCurrentRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCurrentRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCurrentRouteRequest.Merge(m, src)
}
func (m *SetCurrentRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCurrentRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCurrentRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCurrentRouteRequest proto.InternalMessageInfo

func (m *SetCurrentRouteRequest) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

type BotState struct {
	IsBotRunning         bool     `protobuf:"varint,1,opt,name=isBotRunning,proto3" json:"isBotRunning,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BotState) Reset()         { *m = BotState{} }
func (m *BotState) String() string { return proto.CompactTextString(m) }
func (*BotState) ProtoMessage()    {}
func (*BotState) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{2}
}
func (m *BotState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BotState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BotState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotState.Merge(m, src)
}
func (m *BotState) XXX_Size() int {
	return m.Size()
}
func (m *BotState) XXX_DiscardUnknown() {
	xxx_messageInfo_BotState.DiscardUnknown(m)
}

var xxx_messageInfo_BotState proto.InternalMessageInfo

func (m *BotState) GetIsBotRunning() bool {
	if m != nil {
		return m.IsBotRunning
	}
	return false
}

type StartRequest struct {
	Nickname             string   `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartRequest) Reset()         { *m = StartRequest{} }
func (m *StartRequest) String() string { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()    {}
func (*StartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{3}
}
func (m *StartRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRequest.Merge(m, src)
}
func (m *StartRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartRequest proto.InternalMessageInfo

func (m *StartRequest) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

// @TODO: switch to protobuf message instead of json
type GRPCInfos struct {
	Json                 string   `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GRPCInfos) Reset()         { *m = GRPCInfos{} }
func (m *GRPCInfos) String() string { return proto.CompactTextString(m) }
func (*GRPCInfos) ProtoMessage()    {}
func (*GRPCInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{4}
}
func (m *GRPCInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GRPCInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GRPCInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GRPCInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GRPCInfos.Merge(m, src)
}
func (m *GRPCInfos) XXX_Size() int {
	return m.Size()
}
func (m *GRPCInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_GRPCInfos.DiscardUnknown(m)
}

var xxx_messageInfo_GRPCInfos proto.InternalMessageInfo

func (m *GRPCInfos) GetJson() string {
	if m != nil {
		return m.Json
	}
	return ""
}

// @TODO: switch to protobuf message instead of json
type NetworkConfig struct {
	Json                 string   `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkConfig) Reset()         { *m = NetworkConfig{} }
func (m *NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkConfig) ProtoMessage()    {}
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{5}
}
func (m *NetworkConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfig.Merge(m, src)
}
func (m *NetworkConfig) XXX_Size() int {
	return m.Size()
}
func (m *NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfig proto.InternalMessageInfo

func (m *NetworkConfig) GetJson() string {
	if m != nil {
		return m.Json
	}
	return ""
}

type SQLConfig struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SQLConfig) Reset()         { *m = SQLConfig{} }
func (m *SQLConfig) String() string { return proto.CompactTextString(m) }
func (*SQLConfig) ProtoMessage()    {}
func (*SQLConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{6}
}
func (m *SQLConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLConfig.Merge(m, src)
}
func (m *SQLConfig) XXX_Size() int {
	return m.Size()
}
func (m *SQLConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SQLConfig proto.InternalMessageInfo

func (m *SQLConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SQLConfig) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type Config struct {
	SqlOpts          *SQLConfig `protobuf:"bytes,1,opt,name=sqlOpts,proto3" json:"sqlOpts,omitempty"`
	GrpcBind         string     `protobuf:"bytes,2,opt,name=grpcBind,proto3" json:"grpcBind,omitempty"`
	GqlBind          string     `protobuf:"bytes,3,opt,name=gqlBind,proto3" json:"gqlBind,omitempty"`
	GrpcWebBind      string     `protobuf:"bytes,25,opt,name=grpcWebBind,proto3" json:"grpcWebBind,omitempty"`
	HideBanner       bool       `protobuf:"varint,4,opt,name=hideBanner,proto3" json:"hideBanner,omitempty"`
	DropDatabase     bool       `protobuf:"varint,5,opt,name=dropDatabase,proto3" json:"dropDatabase,omitempty"`
	InitOnly         bool       `protobuf:"varint,6,opt,name=initOnly,proto3" json:"initOnly,omitempty"`
	WithBot          bool       `protobuf:"varint,7,opt,name=withBot,proto3" json:"withBot,omitempty"`
	Notification     bool       `protobuf:"varint,8,opt,name=notification,proto3" json:"notification,omitempty"`
	ApnsCerts        []string   `protobuf:"bytes,9,rep,name=apnsCerts,proto3" json:"apnsCerts,omitempty"`
	ApnsDevVoipCerts []string   `protobuf:"bytes,10,rep,name=apnsDevVoipCerts,proto3" json:"apnsDevVoipCerts,omitempty"`
	FcmAPIKeys       []string   `protobuf:"bytes,11,rep,name=fcmAPIKeys,proto3" json:"fcmAPIKeys,omitempty"`
	PrivateKeyFile   string     `protobuf:"bytes,12,opt,name=privateKeyFile,proto3" json:"privateKeyFile,omitempty"`
	// p2p
	PeerCache            bool     `protobuf:"varint,13,opt,name=peerCache,proto3" json:"peerCache,omitempty"`
	Identity             string   `protobuf:"bytes,14,opt,name=identity,proto3" json:"identity,omitempty"`
	Bootstrap            []string `protobuf:"bytes,15,rep,name=bootstrap,proto3" json:"bootstrap,omitempty"`
	NoP2P                bool     `protobuf:"varint,16,opt,name=noP2P,proto3" json:"noP2P,omitempty"`
	BindP2P              []string `protobuf:"bytes,17,rep,name=bindP2P,proto3" json:"bindP2P,omitempty"`
	TransportP2P         []string `protobuf:"bytes,18,rep,name=transportP2P,proto3" json:"transportP2P,omitempty"`
	Hop                  bool     `protobuf:"varint,19,opt,name=hop,proto3" json:"hop,omitempty"`
	Ble                  bool     `protobuf:"varint,20,opt,name=ble,proto3" json:"ble,omitempty"`
	Mdns                 bool     `protobuf:"varint,21,opt,name=mdns,proto3" json:"mdns,omitempty"`
	DhtServer            bool     `protobuf:"varint,22,opt,name=dhtServer,proto3" json:"dhtServer,omitempty"`
	PrivateNetwork       bool     `protobuf:"varint,23,opt,name=PrivateNetwork,proto3" json:"PrivateNetwork,omitempty"`
	SwarmKeyPath         string   `protobuf:"bytes,24,opt,name=SwarmKeyPath,proto3" json:"SwarmKeyPath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{7}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetSqlOpts() *SQLConfig {
	if m != nil {
		return m.SqlOpts
	}
	return nil
}

func (m *Config) GetGrpcBind() string {
	if m != nil {
		return m.GrpcBind
	}
	return ""
}

func (m *Config) GetGqlBind() string {
	if m != nil {
		return m.GqlBind
	}
	return ""
}

func (m *Config) GetGrpcWebBind() string {
	if m != nil {
		return m.GrpcWebBind
	}
	return ""
}

func (m *Config) GetHideBanner() bool {
	if m != nil {
		return m.HideBanner
	}
	return false
}

func (m *Config) GetDropDatabase() bool {
	if m != nil {
		return m.DropDatabase
	}
	return false
}

func (m *Config) GetInitOnly() bool {
	if m != nil {
		return m.InitOnly
	}
	return false
}

func (m *Config) GetWithBot() bool {
	if m != nil {
		return m.WithBot
	}
	return false
}

func (m *Config) GetNotification() bool {
	if m != nil {
		return m.Notification
	}
	return false
}

func (m *Config) GetApnsCerts() []string {
	if m != nil {
		return m.ApnsCerts
	}
	return nil
}

func (m *Config) GetApnsDevVoipCerts() []string {
	if m != nil {
		return m.ApnsDevVoipCerts
	}
	return nil
}

func (m *Config) GetFcmAPIKeys() []string {
	if m != nil {
		return m.FcmAPIKeys
	}
	return nil
}

func (m *Config) GetPrivateKeyFile() string {
	if m != nil {
		return m.PrivateKeyFile
	}
	return ""
}

func (m *Config) GetPeerCache() bool {
	if m != nil {
		return m.PeerCache
	}
	return false
}

func (m *Config) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Config) GetBootstrap() []string {
	if m != nil {
		return m.Bootstrap
	}
	return nil
}

func (m *Config) GetNoP2P() bool {
	if m != nil {
		return m.NoP2P
	}
	return false
}

func (m *Config) GetBindP2P() []string {
	if m != nil {
		return m.BindP2P
	}
	return nil
}

func (m *Config) GetTransportP2P() []string {
	if m != nil {
		return m.TransportP2P
	}
	return nil
}

func (m *Config) GetHop() bool {
	if m != nil {
		return m.Hop
	}
	return false
}

func (m *Config) GetBle() bool {
	if m != nil {
		return m.Ble
	}
	return false
}

func (m *Config) GetMdns() bool {
	if m != nil {
		return m.Mdns
	}
	return false
}

func (m *Config) GetDhtServer() bool {
	if m != nil {
		return m.DhtServer
	}
	return false
}

func (m *Config) GetPrivateNetwork() bool {
	if m != nil {
		return m.PrivateNetwork
	}
	return false
}

func (m *Config) GetSwarmKeyPath() string {
	if m != nil {
		return m.SwarmKeyPath
	}
	return ""
}

// @TODO: list all ports available
type GetPortResponse struct {
	GqlPort              int32    `protobuf:"varint,1,opt,name=gqlPort,proto3" json:"gqlPort,omitempty"`
	GrpcWebPort          int32    `protobuf:"varint,2,opt,name=grpcWebPort,proto3" json:"grpcWebPort,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPortResponse) Reset()         { *m = GetPortResponse{} }
func (m *GetPortResponse) String() string { return proto.CompactTextString(m) }
func (*GetPortResponse) ProtoMessage()    {}
func (*GetPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{8}
}
func (m *GetPortResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPortResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPortResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPortResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPortResponse.Merge(m, src)
}
func (m *GetPortResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetPortResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPortResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPortResponse proto.InternalMessageInfo

func (m *GetPortResponse) GetGqlPort() int32 {
	if m != nil {
		return m.GqlPort
	}
	return 0
}

func (m *GetPortResponse) GetGrpcWebPort() int32 {
	if m != nil {
		return m.GrpcWebPort
	}
	return 0
}

type ListAccountsResponse struct {
	Accounts             []string `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccountsResponse) Reset()         { *m = ListAccountsResponse{} }
func (m *ListAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAccountsResponse) ProtoMessage()    {}
func (*ListAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_622b4ce7acb47fee, []int{9}
}
func (m *ListAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccountsResponse.Merge(m, src)
}
func (m *ListAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccountsResponse proto.InternalMessageInfo

func (m *ListAccountsResponse) GetAccounts() []string {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func init() {
	proto.RegisterType((*Void)(nil), "berty.daemon.Void")
	proto.RegisterType((*SetCurrentRouteRequest)(nil), "berty.daemon.SetCurrentRouteRequest")
	proto.RegisterType((*BotState)(nil), "berty.daemon.BotState")
	proto.RegisterType((*StartRequest)(nil), "berty.daemon.StartRequest")
	proto.RegisterType((*GRPCInfos)(nil), "berty.daemon.GRPCInfos")
	proto.RegisterType((*NetworkConfig)(nil), "berty.daemon.NetworkConfig")
	proto.RegisterType((*SQLConfig)(nil), "berty.daemon.SQLConfig")
	proto.RegisterType((*Config)(nil), "berty.daemon.Config")
	proto.RegisterType((*GetPortResponse)(nil), "berty.daemon.GetPortResponse")
	proto.RegisterType((*ListAccountsResponse)(nil), "berty.daemon.ListAccountsResponse")
}

func init() { proto.RegisterFile("daemon/daemon.proto", fileDescriptor_622b4ce7acb47fee) }

var fileDescriptor_622b4ce7acb47fee = []byte{
	// 914 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xb6, 0x37, 0x89, 0x7f, 0x2a, 0xce, 0xcf, 0x76, 0x42, 0xb6, 0x09, 0x10, 0xa2, 0x01, 0xa1,
	0x68, 0x0f, 0x5e, 0x25, 0xcb, 0x61, 0x17, 0x24, 0xa4, 0xb5, 0x03, 0xde, 0x28, 0x59, 0xd6, 0x8c,
	0xc5, 0x22, 0x71, 0x6b, 0xcf, 0x54, 0xe2, 0x26, 0x76, 0xf7, 0xa4, 0xa7, 0x9c, 0xc8, 0xbc, 0x05,
	0x37, 0x1e, 0x89, 0x23, 0x8f, 0x80, 0xc2, 0x95, 0x87, 0x40, 0xdd, 0x33, 0x9e, 0xcc, 0x98, 0x09,
	0x22, 0x9c, 0xdc, 0xf5, 0xd5, 0x57, 0xd5, 0x35, 0x5f, 0x77, 0x55, 0x1b, 0xb6, 0x42, 0x81, 0x13,
	0xad, 0x9e, 0x25, 0x3f, 0xed, 0xc8, 0x68, 0xd2, 0xac, 0x35, 0x44, 0x43, 0xb3, 0x76, 0x82, 0x79,
	0x35, 0x58, 0x7e, 0xa7, 0x65, 0xe8, 0xb5, 0x61, 0x67, 0x80, 0xd4, 0x9d, 0x1a, 0x83, 0x8a, 0x7c,
	0x3d, 0x25, 0xf4, 0xf1, 0x6a, 0x8a, 0x31, 0xb1, 0x6d, 0x58, 0x31, 0xd6, 0xe6, 0xd5, 0xfd, 0xea,
	0x41, 0xd3, 0x4f, 0x0c, 0xaf, 0x0d, 0x8d, 0x8e, 0xa6, 0x01, 0x09, 0x42, 0xe6, 0x41, 0x4b, 0xc6,
	0x1d, 0x4d, 0xfe, 0x54, 0x29, 0xa9, 0x2e, 0x1c, 0xb1, 0xe1, 0x17, 0x30, 0xef, 0x29, 0xb4, 0x06,
	0x24, 0x0c, 0xcd, 0xb3, 0xee, 0x42, 0x43, 0xc9, 0xe0, 0x52, 0x89, 0xc9, 0x3c, 0x71, 0x66, 0x7b,
	0x1f, 0x43, 0xb3, 0xe7, 0xf7, 0xbb, 0x27, 0xea, 0x5c, 0xc7, 0x8c, 0xc1, 0xf2, 0x4f, 0xb1, 0x56,
	0x29, 0xc9, 0xad, 0xbd, 0x4f, 0x60, 0xed, 0x5b, 0xa4, 0x1b, 0x6d, 0x2e, 0xbb, 0x5a, 0x9d, 0xcb,
	0x8b, 0x52, 0xd2, 0x21, 0x34, 0x07, 0xdf, 0x9d, 0xdd, 0x11, 0x72, 0x5b, 0xb9, 0x35, 0xdb, 0x84,
	0xa5, 0x4b, 0x9c, 0xf1, 0x47, 0x0e, 0xb2, 0x4b, 0xef, 0x97, 0x1a, 0xd4, 0xd2, 0x80, 0x43, 0xa8,
	0xc7, 0x57, 0xe3, 0xb7, 0x11, 0xc5, 0x2e, 0x66, 0xf5, 0xe8, 0x49, 0x3b, 0xaf, 0x5b, 0x3b, 0x4b,
	0xed, 0xcf, 0x79, 0xf6, 0x93, 0x2e, 0x4c, 0x14, 0x74, 0xa4, 0x0a, 0xd3, 0xa4, 0x99, 0xcd, 0x38,
	0xd4, 0x2f, 0xae, 0xc6, 0xce, 0xb5, 0xe4, 0x5c, 0x73, 0x93, 0xed, 0xc3, 0xaa, 0x65, 0xfd, 0x80,
	0x43, 0xe7, 0x7d, 0xdf, 0x79, 0xf3, 0x10, 0xdb, 0x03, 0x18, 0xc9, 0x10, 0x3b, 0x42, 0x29, 0x34,
	0x7c, 0xd9, 0x89, 0x9b, 0x43, 0xac, 0xfc, 0xa1, 0xd1, 0xd1, 0xb1, 0x20, 0x31, 0x14, 0x31, 0xf2,
	0x95, 0x44, 0xfe, 0x3c, 0x66, 0x6b, 0x93, 0x4a, 0xd2, 0x5b, 0x35, 0x9e, 0xf1, 0x9a, 0xf3, 0x67,
	0xb6, 0xad, 0xed, 0x46, 0xd2, 0xa8, 0xa3, 0x89, 0xd7, 0x9d, 0x6b, 0x6e, 0xda, 0xcc, 0x4a, 0x93,
	0x3c, 0x97, 0x81, 0x20, 0xa9, 0x15, 0x6f, 0x24, 0x99, 0xf3, 0x18, 0xfb, 0x10, 0x9a, 0x22, 0x52,
	0x71, 0x17, 0x0d, 0xc5, 0xbc, 0xb9, 0xbf, 0x74, 0xd0, 0xf4, 0xef, 0x00, 0xf6, 0x14, 0x36, 0xad,
	0x71, 0x8c, 0xd7, 0xef, 0xb4, 0x8c, 0x12, 0x12, 0x38, 0xd2, 0x3f, 0x70, 0xfb, 0x9d, 0xe7, 0xc1,
	0xe4, 0x55, 0xff, 0xe4, 0x14, 0x67, 0x31, 0x5f, 0x75, 0xac, 0x1c, 0xc2, 0x3e, 0x83, 0xf5, 0xc8,
	0xc8, 0x6b, 0x41, 0x78, 0x8a, 0xb3, 0x6f, 0xe4, 0x18, 0x79, 0xcb, 0x89, 0xb5, 0x80, 0xda, 0x8a,
	0x22, 0x44, 0xd3, 0x15, 0xc1, 0x08, 0xf9, 0x9a, 0x2b, 0xf9, 0x0e, 0x70, 0x4a, 0x84, 0xa8, 0x48,
	0xd2, 0x8c, 0xaf, 0x27, 0xa7, 0x34, 0xb7, 0x6d, 0xe4, 0x50, 0x6b, 0x8a, 0xc9, 0x88, 0x88, 0x6f,
	0x24, 0xdf, 0x92, 0x01, 0xb6, 0x11, 0x94, 0xee, 0x1f, 0xf5, 0xf9, 0xa6, 0xcb, 0x99, 0x18, 0x56,
	0xbd, 0xa1, 0x54, 0xa1, 0xc5, 0x1f, 0xbb, 0x88, 0xb9, 0x69, 0xd5, 0x23, 0x23, 0x54, 0x1c, 0x69,
	0x43, 0xd6, 0xcd, 0x9c, 0xbb, 0x80, 0xd9, 0x3b, 0x38, 0xd2, 0x11, 0xdf, 0x72, 0x19, 0xed, 0xd2,
	0x22, 0xc3, 0x31, 0xf2, 0xed, 0x04, 0x19, 0x8e, 0xd1, 0xde, 0xdd, 0x49, 0xa8, 0x62, 0xfe, 0x9e,
	0x83, 0xdc, 0xda, 0x56, 0x1a, 0x8e, 0x68, 0x80, 0xe6, 0x1a, 0x0d, 0xdf, 0x49, 0xbe, 0x31, 0x03,
	0xac, 0x52, 0xfd, 0x44, 0x93, 0xb4, 0x4d, 0xf8, 0x13, 0x47, 0x59, 0x40, 0x6d, 0x85, 0x83, 0x1b,
	0x61, 0x26, 0xa7, 0x38, 0xeb, 0x0b, 0x1a, 0x71, 0xee, 0xf4, 0x28, 0x60, 0xde, 0x1b, 0xd8, 0xe8,
	0x21, 0xf5, 0xb5, 0x6d, 0xdd, 0x38, 0xd2, 0x2a, 0xc6, 0xf4, 0x32, 0x5b, 0xc8, 0xf5, 0xc6, 0x8a,
	0x3f, 0x37, 0x73, 0x97, 0xd9, 0x79, 0x1f, 0x39, 0x6f, 0x1e, 0xf2, 0x8e, 0x60, 0xfb, 0x4c, 0xc6,
	0xf4, 0x2a, 0x08, 0xf4, 0x54, 0x51, 0x9c, 0xe5, 0xdc, 0x85, 0x86, 0x48, 0x31, 0x5e, 0x75, 0x42,
	0x65, 0xf6, 0xd1, 0x5f, 0x75, 0xa8, 0x1d, 0xbb, 0xb6, 0x63, 0x2f, 0xa0, 0x75, 0x9c, 0xbf, 0xd7,
	0xac, 0xd8, 0x95, 0x76, 0x94, 0xed, 0x96, 0x60, 0x5e, 0x85, 0x75, 0xe0, 0x71, 0x0f, 0xe9, 0x4c,
	0x07, 0x62, 0xdc, 0x33, 0x51, 0x90, 0x0e, 0x97, 0x92, 0xf0, 0x85, 0x46, 0xcf, 0x26, 0x91, 0x57,
	0x61, 0x5f, 0xc3, 0x66, 0x0f, 0x69, 0x61, 0xf4, 0x94, 0xa4, 0xf8, 0xa0, 0x88, 0x15, 0x02, 0xbc,
	0x0a, 0xfb, 0x0a, 0xea, 0xa9, 0xa4, 0xa5, 0xd1, 0x1f, 0x2d, 0x14, 0x50, 0x54, 0xdf, 0xab, 0xb0,
	0x17, 0x00, 0x27, 0x4a, 0x92, 0x14, 0x63, 0xf9, 0x33, 0xb2, 0xed, 0x22, 0x3d, 0xd9, 0xe5, 0x1e,
	0x11, 0xbe, 0x84, 0xd5, 0x1e, 0x52, 0x36, 0xb8, 0xcb, 0x76, 0xdf, 0x29, 0x62, 0x73, 0xae, 0x57,
	0x61, 0xaf, 0xa1, 0x95, 0x3f, 0xba, 0xd2, 0x68, 0xaf, 0x88, 0x95, 0x1d, 0xb5, 0x57, 0x61, 0x87,
	0xb0, 0xd2, 0x17, 0x4a, 0x06, 0x0f, 0x38, 0xbe, 0xe7, 0x50, 0xf7, 0x31, 0xb6, 0x2f, 0xc8, 0x03,
	0x82, 0xde, 0xc0, 0xc6, 0xc2, 0xa3, 0xc6, 0x3e, 0x5d, 0x18, 0xe3, 0xa5, 0x6f, 0xde, 0x3d, 0xe9,
	0x5e, 0xc2, 0x8a, 0x7b, 0xc3, 0xd8, 0xee, 0x42, 0x92, 0xdc, 0xc3, 0x76, 0x4f, 0xe8, 0xe7, 0xd0,
	0x70, 0x2c, 0x3b, 0x55, 0xff, 0x7b, 0xfd, 0x5f, 0xc0, 0xba, 0x8b, 0x4a, 0x6e, 0xad, 0xdf, 0xef,
	0x3e, 0x4c, 0xb0, 0x01, 0xe9, 0xe8, 0x61, 0x1b, 0xbe, 0x84, 0x35, 0x1b, 0xf4, 0x7f, 0xf6, 0x7b,
	0x0d, 0x5b, 0xdf, 0x47, 0xe1, 0xdd, 0x70, 0x49, 0xdb, 0xe3, 0xdf, 0x5a, 0xa1, 0x3c, 0x53, 0xe7,
	0xe0, 0xb7, 0xdb, 0xbd, 0xea, 0xef, 0xb7, 0x7b, 0xd5, 0x3f, 0x6e, 0xf7, 0xaa, 0xbf, 0xfe, 0xb9,
	0x57, 0xf9, 0x71, 0x27, 0xa1, 0x11, 0x06, 0xa3, 0x67, 0x81, 0x36, 0x98, 0xfe, 0xa1, 0x19, 0xd6,
	0xdc, 0x3f, 0x9a, 0xe7, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xf8, 0xcb, 0x31, 0xed, 0xe8, 0x08,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DaemonClient interface {
	DropDatabase(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	GetLocalGrpcInfos(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GRPCInfos, error)
	GetNetworkConfig(ctx context.Context, in *Void, opts ...grpc.CallOption) (*NetworkConfig, error)
	GetPort(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GetPortResponse, error)
	Initialize(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error)
	GetBotState(ctx context.Context, in *Void, opts ...grpc.CallOption) (*BotState, error)
	ListAccounts(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	Panic(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	Restart(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	SetCurrentRoute(ctx context.Context, in *SetCurrentRouteRequest, opts ...grpc.CallOption) (*Void, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Void, error)
	StartBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StartLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StopBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	StopLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	UpdateNetworkConfig(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*Void, error)
}

type daemonClient struct {
	cc *grpc.ClientConn
}

func NewDaemonClient(cc *grpc.ClientConn) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) DropDatabase(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/DropDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetLocalGrpcInfos(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GRPCInfos, error) {
	out := new(GRPCInfos)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetLocalGrpcInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetNetworkConfig(ctx context.Context, in *Void, opts ...grpc.CallOption) (*NetworkConfig, error) {
	out := new(NetworkConfig)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetPort(ctx context.Context, in *Void, opts ...grpc.CallOption) (*GetPortResponse, error) {
	out := new(GetPortResponse)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Initialize(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Initialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetBotState(ctx context.Context, in *Void, opts ...grpc.CallOption) (*BotState, error) {
	out := new(BotState)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/GetBotState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListAccounts(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/ListAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Panic(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Panic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Restart(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetCurrentRoute(ctx context.Context, in *SetCurrentRouteRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/SetCurrentRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StartBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StartBot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StartLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StartLocalGRPC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StopBot(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StopBot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StopLocalGRPC(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/StopLocalGRPC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UpdateNetworkConfig(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/berty.daemon.Daemon/UpdateNetworkConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
type DaemonServer interface {
	DropDatabase(context.Context, *Void) (*Void, error)
	GetLocalGrpcInfos(context.Context, *Void) (*GRPCInfos, error)
	GetNetworkConfig(context.Context, *Void) (*NetworkConfig, error)
	GetPort(context.Context, *Void) (*GetPortResponse, error)
	Initialize(context.Context, *Config) (*Void, error)
	GetBotState(context.Context, *Void) (*BotState, error)
	ListAccounts(context.Context, *Void) (*ListAccountsResponse, error)
	Panic(context.Context, *Void) (*Void, error)
	Restart(context.Context, *Void) (*Void, error)
	SetCurrentRoute(context.Context, *SetCurrentRouteRequest) (*Void, error)
	Start(context.Context, *StartRequest) (*Void, error)
	StartBot(context.Context, *Void) (*Void, error)
	StartLocalGRPC(context.Context, *Void) (*Void, error)
	StopBot(context.Context, *Void) (*Void, error)
	StopLocalGRPC(context.Context, *Void) (*Void, error)
	UpdateNetworkConfig(context.Context, *NetworkConfig) (*Void, error)
}

func RegisterDaemonServer(s *grpc.Server, srv DaemonServer) {
	s.RegisterService(&_Daemon_serviceDesc, srv)
}

func _Daemon_DropDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).DropDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/DropDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).DropDatabase(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetLocalGrpcInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetLocalGrpcInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetLocalGrpcInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetLocalGrpcInfos(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetNetworkConfig(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetPort(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Initialize(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetBotState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetBotState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/GetBotState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetBotState(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/ListAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListAccounts(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Panic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Panic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Panic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Panic(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Restart(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetCurrentRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCurrentRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetCurrentRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/SetCurrentRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetCurrentRoute(ctx, req.(*SetCurrentRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StartBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StartBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StartBot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StartBot(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StartLocalGRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StartLocalGRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StartLocalGRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StartLocalGRPC(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StopBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StopBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StopBot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StopBot(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StopLocalGRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StopLocalGRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/StopLocalGRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StopLocalGRPC(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UpdateNetworkConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UpdateNetworkConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/berty.daemon.Daemon/UpdateNetworkConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UpdateNetworkConfig(ctx, req.(*NetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

var _Daemon_serviceDesc = grpc.ServiceDesc{
	ServiceName: "berty.daemon.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DropDatabase",
			Handler:    _Daemon_DropDatabase_Handler,
		},
		{
			MethodName: "GetLocalGrpcInfos",
			Handler:    _Daemon_GetLocalGrpcInfos_Handler,
		},
		{
			MethodName: "GetNetworkConfig",
			Handler:    _Daemon_GetNetworkConfig_Handler,
		},
		{
			MethodName: "GetPort",
			Handler:    _Daemon_GetPort_Handler,
		},
		{
			MethodName: "Initialize",
			Handler:    _Daemon_Initialize_Handler,
		},
		{
			MethodName: "GetBotState",
			Handler:    _Daemon_GetBotState_Handler,
		},
		{
			MethodName: "ListAccounts",
			Handler:    _Daemon_ListAccounts_Handler,
		},
		{
			MethodName: "Panic",
			Handler:    _Daemon_Panic_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _Daemon_Restart_Handler,
		},
		{
			MethodName: "SetCurrentRoute",
			Handler:    _Daemon_SetCurrentRoute_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Daemon_Start_Handler,
		},
		{
			MethodName: "StartBot",
			Handler:    _Daemon_StartBot_Handler,
		},
		{
			MethodName: "StartLocalGRPC",
			Handler:    _Daemon_StartLocalGRPC_Handler,
		},
		{
			MethodName: "StopBot",
			Handler:    _Daemon_StopBot_Handler,
		},
		{
			MethodName: "StopLocalGRPC",
			Handler:    _Daemon_StopLocalGRPC_Handler,
		},
		{
			MethodName: "UpdateNetworkConfig",
			Handler:    _Daemon_UpdateNetworkConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon/daemon.proto",
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetCurrentRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCurrentRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Route) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Route)))
		i += copy(dAtA[i:], m.Route)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BotState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsBotRunning {
		dAtA[i] = 0x8
		i++
		if m.IsBotRunning {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StartRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nickname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GRPCInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GRPCInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Json)))
		i += copy(dAtA[i:], m.Json)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Json) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Json)))
		i += copy(dAtA[i:], m.Json)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SQLConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SqlOpts != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.SqlOpts.Size()))
		n1, err1 := m.SqlOpts.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.GrpcBind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.GrpcBind)))
		i += copy(dAtA[i:], m.GrpcBind)
	}
	if len(m.GqlBind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.GqlBind)))
		i += copy(dAtA[i:], m.GqlBind)
	}
	if m.HideBanner {
		dAtA[i] = 0x20
		i++
		if m.HideBanner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropDatabase {
		dAtA[i] = 0x28
		i++
		if m.DropDatabase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InitOnly {
		dAtA[i] = 0x30
		i++
		if m.InitOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WithBot {
		dAtA[i] = 0x38
		i++
		if m.WithBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Notification {
		dAtA[i] = 0x40
		i++
		if m.Notification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ApnsCerts) > 0 {
		for _, s := range m.ApnsCerts {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ApnsDevVoipCerts) > 0 {
		for _, s := range m.ApnsDevVoipCerts {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.FcmAPIKeys) > 0 {
		for _, s := range m.FcmAPIKeys {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PrivateKeyFile) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.PrivateKeyFile)))
		i += copy(dAtA[i:], m.PrivateKeyFile)
	}
	if m.PeerCache {
		dAtA[i] = 0x68
		i++
		if m.PeerCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Identity) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Identity)))
		i += copy(dAtA[i:], m.Identity)
	}
	if len(m.Bootstrap) > 0 {
		for _, s := range m.Bootstrap {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.NoP2P {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.NoP2P {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BindP2P) > 0 {
		for _, s := range m.BindP2P {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.TransportP2P) > 0 {
		for _, s := range m.TransportP2P {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Hop {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Hop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ble {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Ble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mdns {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.Mdns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DhtServer {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.DhtServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrivateNetwork {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.PrivateNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SwarmKeyPath) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.SwarmKeyPath)))
		i += copy(dAtA[i:], m.SwarmKeyPath)
	}
	if len(m.GrpcWebBind) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.GrpcWebBind)))
		i += copy(dAtA[i:], m.GrpcWebBind)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetPortResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPortResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GqlPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.GqlPort))
	}
	if m.GrpcWebPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.GrpcWebPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, s := range m.Accounts {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDaemon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCurrentRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BotState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsBotRunning {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GRPCInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SQLConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlOpts != nil {
		l = m.SqlOpts.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.GrpcBind)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.GqlBind)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.HideBanner {
		n += 2
	}
	if m.DropDatabase {
		n += 2
	}
	if m.InitOnly {
		n += 2
	}
	if m.WithBot {
		n += 2
	}
	if m.Notification {
		n += 2
	}
	if len(m.ApnsCerts) > 0 {
		for _, s := range m.ApnsCerts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.ApnsDevVoipCerts) > 0 {
		for _, s := range m.ApnsDevVoipCerts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.FcmAPIKeys) > 0 {
		for _, s := range m.FcmAPIKeys {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.PrivateKeyFile)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.PeerCache {
		n += 2
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if len(m.Bootstrap) > 0 {
		for _, s := range m.Bootstrap {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.NoP2P {
		n += 3
	}
	if len(m.BindP2P) > 0 {
		for _, s := range m.BindP2P {
			l = len(s)
			n += 2 + l + sovDaemon(uint64(l))
		}
	}
	if len(m.TransportP2P) > 0 {
		for _, s := range m.TransportP2P {
			l = len(s)
			n += 2 + l + sovDaemon(uint64(l))
		}
	}
	if m.Hop {
		n += 3
	}
	if m.Ble {
		n += 3
	}
	if m.Mdns {
		n += 3
	}
	if m.DhtServer {
		n += 3
	}
	if m.PrivateNetwork {
		n += 3
	}
	l = len(m.SwarmKeyPath)
	if l > 0 {
		n += 2 + l + sovDaemon(uint64(l))
	}
	l = len(m.GrpcWebBind)
	if l > 0 {
		n += 2 + l + sovDaemon(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetPortResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GqlPort != 0 {
		n += 1 + sovDaemon(uint64(m.GqlPort))
	}
	if m.GrpcWebPort != 0 {
		n += 1 + sovDaemon(uint64(m.GrpcWebPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, s := range m.Accounts {
			l = len(s)
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDaemon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDaemon(x uint64) (n int) {
	return sovDaemon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCurrentRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCurrentRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCurrentRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBotRunning", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBotRunning = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GRPCInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GRPCInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GRPCInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SqlOpts == nil {
				m.SqlOpts = &SQLConfig{}
			}
			if err := m.SqlOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcBind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcBind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GqlBind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GqlBind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideBanner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HideBanner = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropDatabase = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithBot = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Notification = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApnsCerts = append(m.ApnsCerts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApnsDevVoipCerts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApnsDevVoipCerts = append(m.ApnsDevVoipCerts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FcmAPIKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FcmAPIKeys = append(m.FcmAPIKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerCache = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bootstrap = append(m.Bootstrap, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoP2P", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoP2P = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindP2P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindP2P = append(m.BindP2P, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportP2P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportP2P = append(m.TransportP2P, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hop = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ble = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mdns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mdns = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhtServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DhtServer = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrivateNetwork = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwarmKeyPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwarmKeyPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcWebBind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrpcWebBind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPortResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPortResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPortResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GqlPort", wireType)
			}
			m.GqlPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GqlPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcWebPort", wireType)
			}
			m.GrpcWebPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcWebPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDaemon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDaemon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDaemon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDaemon
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDaemon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDaemon   = fmt.Errorf("proto: integer overflow")
)
