{{~#if (contains filename "api/node/service.proto")~}}

import { observable, computed } from 'mobx'
import Stream from 'stream'
import objectHash from 'object-hash'
import Mutex from 'await-mutex'

  {{#with (lookup 'berty.node.CommitLog.Entity')}}
    {{#each fields}}
      {{#with resolvedType}}
        export class {{name}}EntityStore {
            store = null

            constructor (store, data) {
              this.store = store
              Object.keys(data).forEach(key => (this[key] = data[key]))
            }

            {{#each fields}}
              {{#if (and resolvedType (get (case 'camel' type) ../../../fields))}}
                @computed get {{name}} () {
                  {{#if repeated}}
                    return this.store.entity.{{case 'camel' type}}.values().filter(
                      _ => _.{{case 'camel' ../name}}Id === this.id
                    )
                  {{else}}
                    return this.store.entity.{{case 'camel' type}}.get(this.{{name}}Id)
                  {{/if}}
                }
                set {{name}} ({{case 'camel' name}}) {
                  {{#if repeated}}
                    {{case 'camel' name}}.forEach(_ => this.store.entity.{{case 'camel' type}}.set(
                      _.id,
                      new {{type}}EntityStore(this.store, _),
                    ))
                  {{else}}
                    this.store.entity.{{case 'camel' type}}.set(
                      this.{{name}}Id,
                      new {{type}}EntityStore(this.store, {{case 'camel' name}}),
                    )
                  {{/if}}
                }
              {{else}}
                {{#if repeated}}
                  {{name}} = []
                {{else}}
                  {{name}} = null
                {{/if}}
              {{/if}}
            {{/each}}
        }
      {{/with}}
    {{/each}}
  {{/with}}

  {{#with (lookup 'berty.node.Service')}}

    export class NodeServiceStore {
      constructor (store, bridge) {
        this.store = store
        this.bridge = bridge
        this.commitLogStream({}).then(commitLog => {
          commitLog.on('data', data => {
            // init the stream
          })
        })
      }

      {{#each methods}}

        {{#if responseStream}}
            {{case 'camel' name}}Cache = {}
            {{case 'camel' name}}Mutex = new Mutex()
        {{/if}}

        {{case 'camel' name}} = async (input = {}) => {
          {{#if responseStream}}
            const unlock = await this.{{case 'camel' name}}Mutex.lock()
            const inputHash = objectHash(input)
            if (this.{{case 'camel' name}}Cache[inputHash] == null) {
                const stream = await this.bridge.{{case 'camel' name}}(input)
                this.{{case 'camel' name}}Cache[inputHash] = new Stream.Transform({
                  writableObjectMode: true,
                  readableObjectMode: true,
                  transform: (output, encoding, callback) => {
          {{else}}
            let output = await this.bridge.{{case 'camel' name}}(input)
          {{/if}}

          {{#if (is name 'CommitLogStream')}}
            {{#with resolvedResponseType.nested.Entity}}
              Object.keys(output.entity).forEach(
                key => {
                  let entity = output.entity[key]
                  if (entity == null) {
                    return
                  }
                  switch (key) {
                    default:
                      break
                    {{#each fields}}
                      case '{{name}}':
                        switch (output.operation) {
                          default:
                          case 0:
                          case 1:
                            this.store.entity.{{case 'camel' resolvedType.name}}.set(
                              entity.id,
                              new {{resolvedType.name}}EntityStore(this.store, entity),
                            )
                            break
                          case 2:
                            if (this.store.entity.{{case 'camel' resolvedType.name}}.has(entity.id)) {
                              entity = this.store.entity.{{case 'camel' resolvedType.name}}.get(entity.id)
                              this.store.entity.{{case 'camel' resolvedType.name}}.delete(entity.id)
                            }
                            break
                        }
                        break
                    {{/each}}
                  }
                  output.entity[key] = entity
                }
              )
            {{/with}}
          {{/if}}

          {{#with (lookup 'berty.node.CommitLog.Entity')}}
            {{#each fields}}
              {{#if (eq resolvedType.name ../../resolvedResponseType.name)}}
                {{#if (test ../../name (toRegex '(Remove|Delete)$'))}}
                  if (this.store.entity.{{case 'camel' resolvedType.name}}.has(output.id)) {
                    output = this.store.entity.{{case 'camel' resolvedType.name}}.get(output.id)
                    this.store.entity.{{case 'camel' resolvedType.name}}.delete(output.id)
                  }
                {{else}}
                  output = new {{resolvedType.name}}EntityStore(this.store, output)
                  this.store.entity.{{case 'camel' resolvedType.name}}.set(output.id, output)
                {{/if}}
              {{/if}}
            {{/each}}
          {{/with}}

          {{#if responseStream}}
                    callback(null, output)
                  },
                })
                stream.pipe(this.{{case 'camel' name}}Cache[inputHash])
                this.{{case 'camel' name}}Cache[inputHash].on('end', () => {
                delete this.{{case 'camel' name}}Cache[inputHash]
                })
            }
            const passThroughStream = new Stream.PassThrough({
                writableObjectMode: true,
                readableObjectMode: true,
            })
            this.{{case 'camel' name}}Cache[inputHash].pipe(passThroughStream)
            unlock()
            return passThroughStream
          {{else}}
            return output
          {{/if}}

        }
      {{/each}}
    }
  {{/with}}

  export class Store {
    constructor (bridge) {
      this.bridge = bridge

      this.entity = {
        {{#with (lookup 'berty.node.CommitLog.Entity')}}
          {{#each fields}}
            {{case 'camel' resolvedType.name}}: observable.map({}, { deep: false }),
          {{/each}}
        {{/with}}
      }

      this.node = {
        service: this.bridge.node.service && new NodeServiceStore(this, this.bridge.node.service),
      }

      this.daemon = this.bridge.daemon
    }
  }

{{~/if~}}
