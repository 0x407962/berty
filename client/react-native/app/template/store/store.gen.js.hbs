{{~#if (contains filename "api/node/service.proto")~}}

import { observable, action, computed } from 'mobx'
import EntityStore from './entity'
import hash from 'object-hash'

  {{#with (lookup 'berty.node.CommitLog.Entity')}}
    {{#each fields}}
      {{#with resolvedType}}
        export class {{name}}EntityStore {
            store = null

            constructor (store, data) {
              this.store = store
              Object.keys(data).forEach(key => (this[key] = data[key]))
            }

            {{#each fields}}
              {{#if (and resolvedType (get (case 'camel' type) ../../../fields))}}
                @computed get {{name}} () {
                  {{#if repeated}}
                    return this.store.entity.{{case 'camel' type}}.values().filter(
                      _ => _.{{case 'camel' ../name}}Id === this.id
                    )
                  {{else}}
                    return this.store.entity.{{case 'camel' type}}.get(this.{{name}}Id)
                  {{/if}}
                }
                set {{name}} ({{case 'camel' name}}) {
                  {{#if repeated}}
                    {{case 'camel' name}}.forEach(_ => this.store.entity.{{case 'camel' type}}.set(
                      _.id,
                      new {{type}}EntityStore(this.store, _),
                    ))
                  {{else}}
                    this.store.entity.{{case 'camel' type}}.set(this.{{name}}Id, {{case 'camel' name}})
                  {{/if}}
                }
              {{else}}
                {{#if repeated}}
                  @observable {{name}} = []
                {{else}}
                  @observable {{name}} = null
                {{/if}}
              {{/if}}
            {{/each}}
        }
      {{/with}}
    {{/each}}
  {{/with}}

  {{#with (lookup 'berty.node.Service')}}

    export class NodeServiceStore {
      constructor (store, bridge) {
        this.store = store
        this.bridge = bridge
        this.commitLogStream({})
      }


      {{#each methods}}

        {{#if responseStream}}
          {{case 'camel' name}} = async function * (input) {
        {{else}}
        {{case 'camel' name}} = async (input) => {
        {{/if}}

        {{#if responseStream}}
            for await (let output of await this.bridge.{{case 'camel' name}}(input)) {
        {{else}}
            let output = await this.bridge.{{case 'camel' name}}(input)
        {{/if}}

        {{#if (is name 'CommitLogStream')}}
          {{#with resolvedResponseType.nested.Entity}}
             Object.keys(output.entity).forEach(
               key => {
                 if (output.entity[key] == null) {
                   return
                 }
                 switch (key) {
                   {{#each fields}}
                     case '{{name}}': {
                       output.entity[key] = new {{resolvedType.name}}EntityStore(
                         this.store,
                         output.entity[key],
                       )
                       switch (output.operation) {
                         case 0:
                         case 1:
                           this.store.entity.{{case 'camel' resolvedType.name}}.set(
                             output.entity[key].id,
                             output.entity[key],
                           )
                         case 2:
                           if (this.store.entity.{{case 'camel' resolvedType.name}}.has(
                             output.entity[key].id,
                           )) {
                             this.store.entity.{{case 'camel' resolvedType.name}}.delete(
                               output.entity[key].id,
                             )
                           }
                         default:
                           console.error('commitLog: operation not defined for entity')
                       }
                     }
                   {{/each}}
                 }
               }
             )
          {{/with}}
        {{/if}}
        {{#with (lookup 'berty.node.CommitLog.Entity')}}
          {{#each fields}}
            {{#if (eq resolvedType.name ../../resolvedResponseType.name)}}
              {{#if (test ../../name (toRegex '(Remove|Delete)$'))}}
                if (this.store.entity.{{case 'camel' resolvedType.name}}.has(output.id)) {
                  this.store.entity.{{case 'camel' resolvedType.name}}.delete(output.id)
                }
              {{else}}
                output = new {{resolvedType.name}}EntityStore(this.store, output)
                this.store.entity.{{case 'camel' resolvedType.name}}.set(output.id, output)
              {{/if}}
            {{/if}}
          {{/each}}
        {{/with}}

        {{#if responseStream}}
            yield this.store.entity.{{case 'camel' resolvedResponseType.name}}.get(output.id)
          }
        {{else}}
          return this.store.entity.{{case 'camel' resolvedResponseType.name}}.get(output.id)
        {{/if}}

        {{#if responseStream}}
          }.bind(this)
        {{else}}
          }
        {{/if}}
      {{/each}}
    }
  {{/with}}

  export class Store {
    constructor (bridge) {
      this.bridge = bridge

      this.entity = {
        {{#with (lookup 'berty.node.CommitLog.Entity')}}
          {{#each fields}}
            {{case 'camel' resolvedType.name}}: observable.map({}, { deep: true }),
          {{/each}}
        {{/with}}
      }

      this.node = {
        service: this.bridge.node.service && new NodeServiceStore(this, this.bridge.node.service),
      }
    }
  }

{{~/if~}}
