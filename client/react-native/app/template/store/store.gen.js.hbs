{{~#if (contains filename "api/node/service.proto")~}}

import { observable, action, computed } from 'mobx'
import EntityStore from './entity'
import hash from 'object-hash'
import Stream from 'stream'

  {{#with (lookup 'berty.node.CommitLog.Entity')}}
    {{#each fields}}
      {{#with resolvedType}}
        export class {{name}}EntityStore {
            store = null

            constructor (store, data) {
              this.store = store
              Object.keys(data).forEach(key => (this[key] = data[key]))
            }

            {{#each fields}}
              {{#if (and resolvedType (get (case 'camel' type) ../../../fields))}}
                @computed get {{name}} () {
                  {{#if repeated}}
                    return this.store.entity.{{case 'camel' type}}.values().filter(
                      _ => _.{{case 'camel' ../name}}Id === this.id
                    )
                  {{else}}
                    return this.store.entity.{{case 'camel' type}}.get(this.{{name}}Id)
                  {{/if}}
                }
                set {{name}} ({{case 'camel' name}}) {
                  {{#if repeated}}
                    {{case 'camel' name}}.forEach(_ => this.store.entity.{{case 'camel' type}}.set(
                      _.id,
                      new {{type}}EntityStore(this.store, _),
                    ))
                  {{else}}
                    this.store.entity.{{case 'camel' type}}.set(this.{{name}}Id, {{case 'camel' name}})
                  {{/if}}
                }
              {{else}}
                {{#if repeated}}
                  {{name}} = []
                {{else}}
                  {{name}} = null
                {{/if}}
              {{/if}}
            {{/each}}
        }
      {{/with}}
    {{/each}}
  {{/with}}

  {{#with (lookup 'berty.node.Service')}}

    export class NodeServiceStore {
      constructor (store, bridge) {
        this.store = store
        this.bridge = bridge
        this.commitLogStream({})
      }

      pages = {}

      {{#each methods}}

        {{#if responseStream}}
          {{case 'camel' name}} = async (input) => {
        {{else}}
          {{case 'camel' name}} = async (input) => {
        {{/if}}

          {{#if responseStream}}
            const stream = await this.bridge.{{case 'camel' name}}(input)
            stream.on('data', output => {
          {{else}}
            let output = await this.bridge.{{case 'camel' name}}(input)
          {{/if}}

          {{#if (is name 'CommitLogStream')}}
            {{#with resolvedResponseType.nested.Entity}}
              Object.keys(output.entity).forEach(
                key => {
                  if (output.entity[key] == null) {
                    return
                  }
                  switch (key) {
                    {{#each fields}}
                      case '{{name}}': {
                        switch (output.operation) {
                          case 0:
                          case 1:
                            this.store.entity.{{case 'camel' resolvedType.name}}.set(
                              output.entity[key].id,
                              new {{resolvedType.name}}EntityStore(this.store, output.entity[key]),
                            )
                            break
                          case 2:
                            if (this.store.entity.{{case 'camel' resolvedType.name}}.has(output.entity[key].id)) {
                              this.store.entity.{{case 'camel' resolvedType.name}}.delete(output.entity[key].id)
                            }
                            break
                          default:
                            break
                        }
                      }
                    {{/each}}
                  }
                }
              )
            {{/with}}
          {{/if}}

          {{#with (lookup 'berty.node.CommitLog.Entity')}}
            {{#each fields}}
              {{#if (eq resolvedType.name ../../resolvedResponseType.name)}}
                {{#if (test ../../name (toRegex '(Remove|Delete)$'))}}
                  if (this.store.entity.{{case 'camel' resolvedType.name}}.has(output.id)) {
                    this.store.entity.{{case 'camel' resolvedType.name}}.delete(output.id)
                  }
                {{else}}
                  output = new {{resolvedType.name}}EntityStore(this.store, output)
                  this.store.entity.{{case 'camel' resolvedType.name}}.set(output.id, output)
                {{/if}}
              {{/if}}
            {{/each}}
          {{/with}}

          {{#if responseStream}}
            })
            const copyStream = new Stream.PassThrough()
            stream.pipe(copyStream)
            return copyStream
          {{else}}
            return output
          {{/if}}

        }
      {{/each}}
    }
  {{/with}}

  export class Store {
    constructor (bridge) {
      this.bridge = bridge

      this.entity = {
        {{#with (lookup 'berty.node.CommitLog.Entity')}}
          {{#each fields}}
            {{case 'camel' resolvedType.name}}: observable.map({}, { deep: true }),
          {{/each}}
        {{/with}}
      }

      this.node = {
        service: this.bridge.node.service && new NodeServiceStore(this, this.bridge.node.service),
      }
    }
  }

{{~/if~}}
